# ToDo list

##### Тестовое задание на стажировку в СКБ Контур 2020г.

Алена с друзьями разрабатывает невероятный проект нового поколения. Ребята разработали план, стали его придерживаться, сформировали набор задач и начали выполнять их. Однако они разрабатывали так увлеченно и самозабвенно, что зачастую одну и ту же задачу разные участники решали несколько раз, а некоторые задачи оставались без внимания.

Алена понимала, что такая избыточная работа отдаляет коллектив от релиза. Для решения проблемы она завела рабочий чат, в котором ребята распределяли задачи и делились прогрессом. Но все было тщетно, информация о планировании терялась в бездонном потоке общения команды. Чтобы понять, кто занимается задачей и занимается ли ей кто-то вообще, приходилось листать чат до сообщения, с назначением на задачу. Только представьте как это неудобно!

Перед командой встала проблема оптимизации — как заменить O(количество сообщений в чате) на O(количество задач) при очередном планировании? Коллективно ребята решили разработать простенький ToDo лист, в который будут записывать задачи и прогресс по ним. Они же разработчики как-никак.

В процессе обсуждения особенностей ToDo листа команда пришла к выводу, что приложение должно работать как по сети, так и автономно. У ребят оставался только один вопрос как разрешать конфликты? Например, несколько участников работают в автономно. Один из ребят переименовывает пункт списка, а другой этот же пункт удаляет. Что должно произойти когда участники вернутся в сеть?

Вскоре ответ был найден — Conflict-free Replicated Data Types. С таким подходом даже центральный сервер не понадобится — вся информация будет храниться на компьютерах разработчиков!

Подробнее об этих структурах данных вы можете узнать здесь:

- [Доклад Marc Shapiro на Microsoft Research](https://youtu.be/oyUHd894w18)
- [Статья Russell Sullivan](https://serverless.com/blog/crdt-explained-supercharge-serverless-at-edge/)
- [Статья Антона Загорского](https://habr.com/ru/post/418897/)

[Скачай проект ToDoList.](https://ulearn.me/Exercise/StudentZip?courseId=backend-internship-2020&slideId=c6a70e4d-9673-4d02-a50c-fe667a5bd83a) Тебе предстоит реализовать структуру данных представляющую список. Список пунктов ToDo листа должен быть реализован с семантикой эквивалентной Last Write Wins Map, в котором ключ — идентификатор пункта, а значение — кортеж двух Last Write Wins регистров: первый регистр представляет имя пункта, второй его состояние (выполнен, невыполнен). Удаление, добавление и переименование пункта не должно влиять на его состояние — если удалить выполненный пункт, а потом снова добавить его, то он должен остаться выполненным. В случае конфликта timestamp (у нескольких обновлений timestamp совпадет) используй следующие стратегии:

- удаление пункта имеет приоритет, т.е., если пункт создан и удален с одним timestamp, то он считается удаленным;
- для регистра с именем пункта выбирается такое имя, которое принадлежит пользователю с меньшим id (id выдаются пользователям последовательно, а старые пользователи считаются более опытными, поэтому логично в конфликтных ситуациях использовать их версию);
- для регистра состояния приоритет имеет невыполненное состояние.

Помимо этого, в программе должна быть предусмотрена возможность отстранить пользователя от редактирования списка, в таком случае все его действия должны откатиться так, как если бы он никогда не участвовал в редактировании этого списка. Учтите, что после отстранения пользователя от него все равно могут приходить обновления. После отстранения пользователя его можно вернуть обратно, так все его обновления даже те, которые пришли во время его отстранения, должны быть применены опять.

Сценарий переименования пункта выполняется повторным вызовом метода `AddEntry` с теми же идентификаторами, новым именем и большим timestamp.

При проектировании старайтесь разделить решение на логические части так, чтобы их можно было тестировать и переиспользовать независимо от остального кода.